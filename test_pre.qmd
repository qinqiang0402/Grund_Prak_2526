---
format:
  revealjs:
    embed-resources: true
    slide-number: c
    logo: "images/LMU_Logo.svg"

css: customstyle.css
editor: visual
server: shiny
---

```{r}
#| label: setup
#| include: false

#source("env_setup.R")

# Load packages
library(shiny)
library(tidyverse)
library(readxl)
library(sf)
library(stringr)
library(forcats)
library(ggpubr)
library(leaflet)
library(htmltools)
library(htmlwidgets)

# Load precomputed RDS objects
table_data_01 <- readRDS("results/figures/table/table_data_01.rds")
table_data_02 <- readRDS("results/figures/table/table_data_02.rds")
table_data_03 <- readRDS("results/figures/table/table_data_03.rds")
leaflet_sv_durchschnitt <- readRDS("results/figures/SV/leaflet_sv_durchschnitt.rds")


#_________________________________________________________________________________________________________
# Haushalt mit Kindern (HMK) figures


hmk_korr_point_line_nach_stadtteile_color <- readRDS("results/figures/Haushalt_mit_Kindern/hmk_korr_point_line_nach_stadtteile_color.rds")
hmk_korr_gesamt_point_sw <- readRDS("results/figures/Haushalt_mit_Kindern/hmk_korr_gesamt_point_sw.rds")
hmk_korr_point_line_nach_jahr_color <- readRDS("results/figures/Haushalt_mit_Kindern/hmk_korr_point_line_nach_jahr_color.rds")
# Kinderbetreuung (KI) figures
#______________________________________________________________________________
ki_dual_trend <- readRDS("results/figures/Kinderbetreuung/ki_dual_trend.rds")
ki_map_2015 <- readRDS("results/figures/Kinderbetreuung/map_ki_2015.rds")
sv_map_2015 <- readRDS("results/figures/Kinderbetreuung/map_sv_2015.rds")
ki_point_korr_gesamt_sw <- readRDS("results/figures/Kinderbetreuung/ki_point_korr_gesamt_sw.rds")
ki_korr_jahre_point_line_rot <- readRDS("results/figures/Kinderbetreuung/ki_point_line_rot.rds")
ki_korr_stadtteile_point_line_sw <- readRDS("results/figures/Kinderbetreuung/ki_korr_stadtteile_point_line_sw.rds")

#__________________________________________________________________________
m_effekt_01 <- readRDS("results/figures/m_effekt/m_effekt_01_singleline.rds")
m_effekt_02 <- readRDS("results/figures/m_effekt/m_effekt_02_colored.rds")
m_effekt_2.5 <- readRDS("results/figures/m_effekt/m_effekt_2.5.rds")
m_effekt_03 <- readRDS("results/figures/m_effekt/m_effekt_03.rds")
m_effekt_04 <- readRDS("results/figures/m_effekt/m_effekt_04.rds")
m_effekt_04_plot <- readRDS("results/figures/m_effekt/m_effekt_04_plot.rds")
m_effekt_03_plot <- readRDS("results/figures/m_effekt/m_effekt_03_plot.rds")
#_____________________________________________________________________________
geburtenrate_dual_trend <- readRDS("results/figures/Geburtenrate/geburtenrate_dual_trend.rds")
geburtenrate_trend_nach_stadtteile <- readRDS("results/figures/Geburtenrate/geburtenrate_trend_nach_stadtteile.rds")
geburtenrate_korr_nach_stadtteile <- readRDS("results/figures/Geburtenrate/geburtenrate_korr_nach_stadtteile.rds")
geburtenrate_korr_trend_nach_jahr <- readRDS("results/figures/Geburtenrate/geburtenrate_korr_trend_nach_jahr.rds")

#_______________________________________________________________________________
mea_gesamt_sw <- readRDS("results/figures/MEA/mea_gesamt_sw.rds")
mea_korr_nach_stadtteilen_point <- readRDS("results/figures/MEA/mea_korr_nach_stadtteilen_point.rds")
mea_korr_nach_stadtteilen_point_line <- readRDS("results/figures/MEA/mea_korr_nach_stadtteilen_point_line.rds")
mea_korr_jahr_point <- readRDS("results/figures/MEA/mea_korr_jahr_point.rds")
mea_korr_jahr_point_line <- readRDS("results/figures/MEA/mea_korr_jahr_point_line.rds")
#________________________________________________________________________________




#_______________________________________________________________________________

# =================================================================
#  Data preparation for the Shiny map (ported from Shiny script)
# =================================================================

# 1. Geometrie der Münchner Stadtbezirke laden
munich_map <- st_read("results/geo/bezirk_map.json", quiet = TRUE) |> st_transform(4326)

# 2. Excel-Daten laden
be_sheet <- read_excel("data/raw/export_be.xlsx", sheet = "BEVÖLKERUNG")
ar_sheet <- read_excel("data/raw/export_ar.xlsx", sheet = "ARBEITSMARKT")
ki_sheet <- read_excel("data/raw/export_ki.xlsx", sheet = "KINDERBETREUUNG") 

# 3. Build long-format tables for each indicator (Variable)

# 3.1 Durchschnittsalter Mütter erstgebärend
be_data_long <- be_sheet %>%
  filter(
    Indikator == "Durchschnittsalter Mütter erstgebärend", 
    Ausprägung == "insgesamt", 
    Raumbezug != "Stadt München"
  ) %>%
  mutate(
    age_mean = `Basiswert 1` / `Basiswert 2`,
    bezirksnummer = sprintf("%02d", as.numeric(str_extract(Raumbezug, "^\\d+")))
  ) %>%
  select(Jahr, bezirksnummer, age_mean) %>% 
  filter(!is.na(bezirksnummer))

# 3.2 Anteil Frauenbeschäftigung
ar_data_long <- ar_sheet %>%
  filter(
    Indikator == "Sozialversicherungspflichtig Beschäftigte - Anteil", 
    Ausprägung == "weiblich", 
    Raumbezug != "Stadt München"
  ) %>%
  mutate(
    anteil = 100 * `Basiswert 1` / `Basiswert 2`,
    bezirksnummer = sprintf("%02d", as.numeric(str_extract(Raumbezug, "^\\d+")))
  ) %>%
  select(Jahr, bezirksnummer, anteil) %>% 
  filter(!is.na(bezirksnummer))

# 3.3 Haushalte mit Kindern
hh_data_long <- be_sheet %>%
  filter(
    Indikator == "Haushalte mit Kindern", 
    Ausprägung == "insgesamt", 
    Raumbezug != "Stadt München"
  ) %>%
  mutate(
    anteil_kinder = 100 * `Basiswert 1` / `Basiswert 2`,
    bezirksnummer = sprintf("%02d", as.numeric(str_extract(Raumbezug, "^\\d+")))
  ) %>%
  select(Jahr, bezirksnummer, anteil_kinder) %>% 
  filter(!is.na(bezirksnummer))

# 3.4 Kinderbetreuungsquote 0–2 Jahre
# Schritt A: Nenner (Alle Kinder 0–2) aus BEVÖLKERUNG
df_total <- be_sheet %>%
  filter(
    Indikator == "Altersgruppen", 
    Ausprägung == "bis 2 Jahre", 
    Raumbezug != "Stadt München"
  ) %>%
  select(Jahr, Raumbezug, kinder_total = `Basiswert 1`)

# Schritt B: Zähler (Betreute Kinder) aus KINDERBETREUUNG
df_betreut_raw <- ki_sheet %>%
  filter(
    Indikator == "Altersgruppen", 
    Ausprägung == "bis 2 Jahre", 
    Raumbezug != "Stadt München"
  ) %>%
  select(Jahr, Raumbezug, kinder_betreut = `Basiswert 1`)

# Schritt C: Join + Quote
betreuung_data_long <- df_total %>%
  left_join(df_betreut_raw, by = c("Jahr", "Raumbezug")) %>%
  mutate(
    anteil_betreuung = 100 * kinder_betreut / kinder_total,
    bezirksnummer = sprintf("%02d", as.numeric(str_extract(Raumbezug, "^\\d+")))
  ) %>%
  select(Jahr, bezirksnummer, anteil_betreuung) %>%
  filter(!is.na(bezirksnummer))

# 3.5 Geburtenrate (wie im Shiny-Skript)
gr_data_long <- be_sheet %>%
  filter(
    Indikator == "Allgemeine Geburtenrate",
    Ausprägung == "insgesamt",
    Raumbezug != "Stadt München"
  ) %>%
  mutate(
    new_baby = 100 * `Basiswert 1` / `Basiswert 2`, 
    bezirksnummer = sprintf("%02d", as.numeric(str_extract(Raumbezug, "^\\d+")))
  ) %>%
  select(Jahr, bezirksnummer, new_baby) %>%
  filter(!is.na(bezirksnummer))

# 3.6 Alle Variablen zusammenmergen
combined_data_all <- be_data_long %>%
  full_join(ar_data_long,       by = c("Jahr", "bezirksnummer")) %>%
  full_join(hh_data_long,       by = c("Jahr", "bezirksnummer")) %>%
  full_join(betreuung_data_long,by = c("Jahr", "bezirksnummer")) %>%
  full_join(gr_data_long,       by = c("Jahr", "bezirksnummer"))

# 3.7 Mit Geometrie verknüpfen (sf)
final_sf_data_long <- munich_map %>%
  left_join(combined_data_all, by = c("sb_nummer" = "bezirksnummer")) %>%
  filter(!is.na(Jahr))

# 3.8 Globale Konstanten für Shiny
MAP_NAME_COLUMN <- "name" 
MIN_YEAR <- min(final_sf_data_long$Jahr, na.rm = TRUE)
MAX_YEAR <- max(final_sf_data_long$Jahr, na.rm = TRUE)

variable_choices <- c(
  "Muttererstgeburtsalter"                   = "age_mean",
  "Frauenbeschäftigung (%)"          = "anteil",
  "Haushalte mit Kindern (%)"        = "anteil_kinder",
  "Kinderbetreuung (%)"    = "anteil_betreuung",
  "Geburtenrate (%)"                        = "new_baby"
)

# Globale Min/Max für konsistente Farben
GLOBAL_MIN_AGE        <- min(final_sf_data_long$age_mean,          na.rm = TRUE); GLOBAL_MAX_AGE        <- max(final_sf_data_long$age_mean,          na.rm = TRUE)
GLOBAL_MIN_ANTEIL     <- min(final_sf_data_long$anteil,            na.rm = TRUE); GLOBAL_MAX_ANTEIL     <- max(final_sf_data_long$anteil,            na.rm = TRUE)
GLOBAL_MIN_KINDER     <- min(final_sf_data_long$anteil_kinder,     na.rm = TRUE); GLOBAL_MAX_KINDER     <- max(final_sf_data_long$anteil_kinder,     na.rm = TRUE)
GLOBAL_MIN_BETREUUNG  <- min(final_sf_data_long$anteil_betreuung,  na.rm = TRUE); GLOBAL_MAX_BETREUUNG  <- max(final_sf_data_long$anteil_betreuung,  na.rm = TRUE)
GLOBAL_MIN_BABY       <- min(final_sf_data_long$new_baby,          na.rm = TRUE); GLOBAL_MAX_BABY       <- max(final_sf_data_long$new_baby,          na.rm = TRUE)




# =================================================================
# Shiny-Scatter für Moderierenden Effekt: Daten vorbereiten
# =================================================================

# Bevölkerungsdaten (0–2 Jahre)
be_0bis2 <- be_sheet %>% 
  filter(
    Indikator == "Altersgruppen",
    Ausprägung == "bis 2 Jahre"
  ) %>%
  select(Indikator, Ausprägung, Jahr, Raumbezug, `Basiswert 1`) %>%
  rename(kinder_total = `Basiswert 1`)

# Kinderbetreuungsdaten (0–2 Jahre)
ki_0bis2 <- ki_sheet %>% 
  filter(
    Indikator == "Altersgruppen",
    Ausprägung == "bis 2 Jahre"
  ) %>% 
  select(Indikator, Ausprägung, Jahr, Raumbezug, `Basiswert 1`) %>%
  rename(kinder_betreut = `Basiswert 1`)

# Zusammenführen von Bevölkerung + betreuten Kindern
df_betreut <- left_join(
  be_0bis2, ki_0bis2,
  by = c("Jahr", "Raumbezug", "Indikator", "Ausprägung")
) %>%
  mutate(
    kinder_unbetreut   = kinder_total - kinder_betreut,
    anteil_unbetreut   = kinder_unbetreut / kinder_total * 100,
    anteil_betreut     = kinder_betreut / kinder_total * 100
  )

# Beschäftigungsdaten (Anteil weiblich)
df_emp <- ar_sheet %>%
  filter(
    Indikator == "Sozialversicherungspflichtig Beschäftigte - Anteil",
    Ausprägung == "weiblich"
  ) %>%
  mutate(
    Jahr = as.numeric(Jahr),
    emp_female_pct = 100 * `Basiswert 1` / `Basiswert 2`
  ) %>%
  select(Jahr, Raumbezug, emp_female_pct)

# Haushalte mit Kindern
df_households <- be_sheet %>%
  filter(
    Indikator == "Haushalte mit Kindern",
    Ausprägung == "insgesamt"
  ) %>%
  mutate(
    Jahr = as.numeric(Jahr),
    households_pct = 100 * `Basiswert 1` / `Basiswert 2`
  ) %>%
  select(Jahr, Raumbezug, households_pct)

# Merge Beschäftigte + Haushalte
df_merged <- df_emp %>%
  inner_join(df_households, by = c("Jahr", "Raumbezug"))

```

## 

![](images/clipboard-2869406759.png)

## 

![](images/clipboard-3386569485.png)

## Agenda {.agenda-slide}

1.  Datenüberblick
2.  Datenanalyse
    -   Frauenbeschäftigung
    -   Zusammenhang
        -   Haushalte mit Kindern
        -   Kinderbetreuung
3.  Fazit - Limitation - Ausblick

------------------------------------------------------------------------

## Agenda {.agenda-slide}

1.  Datenüberblick
2.  [Datenanalyse]{.dim-past}
    -   [Frauenbeschäftigung]{.dim-past}
    -   [Zusammenhang]{.dim-past}
        -   [Haushalte mit Kindern]{.dim-past}
        -   [Kinderbetreuung]{.dim-past}
3.  [Fazit - Limitation - Ausblick]{.dim-future}

```{r}

#| label: setup
#| include: false

library(readr)
library(knitr)
library(kableExtra)

# 2) Define a table output function with fixed column widths
#    Purpose: ensure consistent column spacing across different pages

make_daten_table <- function(df) {
  df %>%
    knitr::kable(
      format = "html",
      escape = TRUE,
      align = c("l","l","c","l","c"),
      col.names = c("Indikator", "Ausprägung", "Jahr", "Raumbezug", "Indikatorwert")
    ) %>%
    kable_styling(full_width = TRUE) %>%
    column_spec(1, width = "32%") %>%
    column_spec(2, width = "16%") %>%
    column_spec(3, width = "10%") %>%
    column_spec(4, width = "28%") %>%
    column_spec(5, width = "14%")
}
```

## Daten {.smaller}

```{=html}
<style>
.no-wrap td {
  white-space: nowrap;
}

/* 页脚样式 */
.data-footer {
  font-size: 0.8em;
  color: #555;
  margin-top: 1.5em;
  text-align: left;
}

</style>
```

```{r}
#| echo: false
#| results: asis

make_daten_table(table_data_01)
```

## Daten {.smaller}

```{=html}
<style>
.no-wrap td {
  white-space: nowrap;
}

/* 页脚样式 */
.data-footer {
  font-size: 0.8em;
  color: #555;
  margin-top: 1.5em;
  text-align: left;
}

</style>
```

```{r}
#| echo: false
#| results: asis

make_daten_table(table_data_02)
```

## Daten {.smaller}

```{=html}
<style>
.no-wrap td {
  white-space: nowrap;
}

/* 页脚样式 */
.data-footer {
  font-size: 0.8em;
  color: #555;
  margin-top: 1.5em;
  text-align: left;
}

</style>
```

```{r}
#| echo: false
#| results: asis

make_daten_table(table_data_03)
```

```{=html}
<div class="data-footer">
  Datenquellen: Datengartl'n Stadt München
</div>
```

## Agenda {.agenda-slide}

1.  [Datenüberblick]{.dim-past}
2.  Datenanalyse
    -   Frauenbeschäftigung
    -   [Zusammenhang]{.dim-past}
        -   [Haushalte mit Kindern]{.dim-past}
        -   [Kinderbetreuung]{.dim-past}
3.  [Fazit - Limitation - Ausblick]{.dim-future}

------------------------------------------------------------------------

## Frauenbeschäftigung

*(Anteil weiblicher sozialversicherungspflichtig Beschäftigter)*

<br> <br>

Weibliche Bevölkerung, die in einem Arbeitsverhältnis stehen und deren Einkommen der Pflicht zur Zahlung von Sozialversicherungsbeiträgen unterliegt

## Frauenbeschäftigung 2024

<br>

```{r}

#| echo: false
#| out-width: 100%
#| out-height: 650px
#| fig-align: center

leaflet_sv_durchschnitt


```

::: {style="text-align:left; font-size:2.0rem; margin-top:12px;"}
Der gesamtstädtische Durchschnitt liegt bei 62,6 %.
:::

```{r}
#| context: server



    addLegend_decreasing <- function (map, position = c("topright", "bottomright", "bottomleft","topleft"),
                                  pal, values, na.label = "NA", bins = 7, colors, 
                                  opacity = 0.5, labels = NULL, labFormat = labelFormat(), 
                                  title = NULL, className = "info legend", layerId = NULL, 
                                  group = NULL, data = getMapData(map), decreasing = FALSE) {
  
        position <- match.arg(position)
        type <- "unknown"
        na.color <- NULL
        extra <- NULL
        if (!missing(pal)) {
            if (!missing(colors)) 
                stop("You must provide either 'pal' or 'colors' (not both)")
            if (missing(title) && inherits(values, "formula")) 
                title <- deparse(values[[2]])
            values <- evalFormula(values, data)
            type <- attr(pal, "colorType", exact = TRUE)
            args <- attr(pal, "colorArgs", exact = TRUE)
            na.color <- args$na.color
            if (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == 
                    0) {
                na.color <- NULL
            }
            if (type != "numeric" && !missing(bins)) 
                warning("'bins' is ignored because the palette type is not numeric")
            if (type == "numeric") {
                cuts <- if (length(bins) == 1) 
                    pretty(values, bins)
                else bins   
                if (length(bins) > 2) 
                    if (!all(abs(diff(bins, differences = 2)) <= 
                                     sqrt(.Machine$double.eps))) 
                        stop("The vector of breaks 'bins' must be equally spaced")
                n <- length(cuts)
                r <- range(values, na.rm = TRUE)
                cuts <- cuts[cuts >= r[1] & cuts <= r[2]]
                n <- length(cuts)
                p <- (cuts - r[1])/(r[2] - r[1])
                extra <- list(p_1 = p[1], p_n = p[n])
                p <- c("", paste0(100 * p, "%"), "")
                if (decreasing == TRUE){
                    colors <- pal(rev(c(r[1], cuts, r[2])))
                    labels <- rev(labFormat(type = "numeric", cuts))
                }else{
                    colors <- pal(c(r[1], cuts, r[2]))
                    labels <- rev(labFormat(type = "numeric", cuts))
                }
                colors <- paste(colors, p, sep = " ", collapse = ", ")
            }
            else if (type == "bin") {
                cuts <- args$bins
                n <- length(cuts)
                mids <- (cuts[-1] + cuts[-n])/2
                if (decreasing == TRUE){
                    colors <- pal(rev(mids))
                    labels <- rev(labFormat(type = "bin", cuts))
                }else{
                    colors <- pal(mids)
                    labels <- labFormat(type = "bin", cuts)
                }
            }
            else if (type == "quantile") {
                p <- args$probs
                n <- length(p)
                cuts <- quantile(values, probs = p, na.rm = TRUE)
                mids <- quantile(values, probs = (p[-1] + p[-n])/2, na.rm = TRUE)
                if (decreasing == TRUE){
                    colors <- pal(rev(mids))
                    labels <- rev(labFormat(type = "quantile", cuts, p))
                }else{
                    colors <- pal(mids)
                    labels <- labFormat(type = "quantile", cuts, p)
                }
            }
            else if (type == "factor") {
                v <- sort(unique(na.omit(values)))
                colors <- pal(v)
                labels <- labFormat(type = "factor", v)
                if (decreasing == TRUE){
                    colors <- pal(rev(v))
                    labels <- rev(labFormat(type = "factor", v))
                }else{
                    colors <- pal(v)
                    labels <- labFormat(type = "factor", v)
                }
            }
            else stop("Palette function not supported")
            if (!any(is.na(values))) 
                na.color <- NULL
        }
        else {
            if (length(colors) != length(labels)) 
                stop("'colors' and 'labels' must be of the same length")
        }
        legend <- list(colors = I(unname(colors)), labels = I(unname(labels)), 
                                     na_color = na.color, na_label = na.label, opacity = opacity, 
                                     position = position, type = type, title = title, extra = extra, 
                                     layerId = layerId, className = className, group = group)
        invokeMethod(map, data, "addLegend", legend)
        }


#__________________________


# ---- Play / Pause state ----
playing <- reactiveVal(FALSE)

# Toggle play state when the button is clicked + update the button label accordingly
observeEvent(input$play_pause, {
  if (playing()) {
    playing(FALSE)
    updateActionButton(session, "play_pause", label = "▶ Play")
  } else {
    playing(TRUE)
    updateActionButton(session, "play_pause", label = "⏸ Pause")
  }
})

# Auto-advance the year (only runs while playing() == TRUE)
observe({
  req(playing())                  
  invalidateLater(1000, session)  

  current   <- isolate(input$time_slider)
  next_year <- if (current >= MAX_YEAR) MIN_YEAR else current + 1L

  updateSliderInput(session, "time_slider", value = next_year)
})

# 1. Reaktive gefilterte Daten (immer aktuelles Jahr + gewählte Variable)
filtered_sf_data <- reactive({
  final_sf_data_long %>% 
    filter(Jahr == input$time_slider) %>%
    select(
      sb_nummer,
      !!sym(MAP_NAME_COLUMN),
      geometry,
      Value = !!sym(input$variable_select)
    )
})

# 2. Grundkarte (wird einmal initialisiert)
output$map_output <- renderLeaflet({
  leaflet(options = leafletOptions(minZoom = 10, maxZoom = 14)) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%   
    setView(lng = 11.5761, lat = 48.1372, zoom = 10)
})

# 3. Karte bei Änderung von Slider / Variable neu einfärben
observe({
  current_sf <- filtered_sf_data()
  var_id     <- input$variable_select
  var_label  <- names(variable_choices)[variable_choices == var_id]
  
  # ---- Farbbereich & Einheit je nach Variable ----
  if (var_id == "age_mean") {
    c_min <- GLOBAL_MIN_AGE;       c_max <- GLOBAL_MAX_AGE
    unit  <- " Jahre";             dec   <- 2
    pal_name <- "RdPu"
    
  } else if (var_id == "anteil") {
    c_min <- GLOBAL_MIN_ANTEIL;    c_max <- GLOBAL_MAX_ANTEIL
    unit  <- " %";                 dec   <- 1
    pal_name <- "Blues"
    
  } else if (var_id == "anteil_kinder") {
    c_min <- GLOBAL_MIN_KINDER;    c_max <- GLOBAL_MAX_KINDER
    unit  <- " %";                 dec   <- 1
    pal_name <- "Greens"
    
  } else if (var_id == "anteil_betreuung") {
    c_min <- GLOBAL_MIN_BETREUUNG; c_max <- GLOBAL_MAX_BETREUUNG
    unit  <- " %";                 dec   <- 1
    pal_name <- "Reds"
    
  } else {
    c_min <- GLOBAL_MIN_BABY;      c_max <- GLOBAL_MAX_BABY
    unit  <- "";                   dec   <- 4
    pal_name <- "Purples"
  }
  
  pal <- colorNumeric(palette = pal_name, domain = c(c_min, c_max))
  
  popup_content <- paste0(
    "<b>Stadtteil:</b> ", current_sf[[MAP_NAME_COLUMN]], "<br/>",
    "<b>", var_label, ":</b> ", round(current_sf$Value, dec), unit
  )
  
  leafletProxy("map_output", data = current_sf) %>%
    clearShapes() %>%
    clearControls() %>%
    addPolygons(
      fillColor = ~pal(Value),
      weight = 1.5,
      opacity = 1,
      color = "white",
      dashArray = "1",
      fillOpacity = 0.7,
      label = lapply(popup_content, HTML),
      highlightOptions = highlightOptions(
        weight = 3,
        color  = "#666",
        fillOpacity = 0.9,
        bringToFront = TRUE
      )
    ) %>%
    addLegend_decreasing(
      pal      = pal,
      decreasing = TRUE,
      values   = c(c_min, c_max),
      opacity  = 0.7,
      title    = var_label,
      labFormat= labelFormat(suffix = unit, digits = 1),
      position = "bottomright"
    ) %>%
    addControl(
      html = sprintf(
        "<div style='font-size:26px;
                     font-weight:bold;
                     background:rgba(255,255,255,0.8);
                     padding:4px 8px;
                     border-radius:4px;
                     box-shadow:0 0 3px rgba(0,0,0,0.3);'>
           Jahr: %s
         </div>",
        input$time_slider
      ),
      position = "topright"
    )
})



```

## Frauenbeschäftigung

```{r}
#| panel: sidebar
#| 
selectInput(
  "variable_select",
  "",
  choices  = variable_choices,
  selected = "anteil"   
)

sliderInput(
  "time_slider",
  "Jahr",
  min     = MIN_YEAR,
  max     = MAX_YEAR,
  value   = MAX_YEAR,
  step    = 1,
  sep     = "",
  animate = FALSE
)

actionButton(
  "play_pause",
  "▶ Play",
  width = "100%"
)
```

```{r}
#| panel: fill

leafletOutput("map_output", height = "550px")
```

------------------------------------------------------------------------

## Agenda {.agenda-slide}

1.  [Datenüberblick]{.dim-past}
2.  Datenanalyse
    -   [Frauenbeschäftigung]{.dim-past}
    -   Zusammenhang
        -   Haushalte mit Kindern
        -   [Kinderbetreuung]{.dim-past}
3.  [Fazit - Limitation - Ausblick]{.dim-future}

## Haushalte mit Kindern

<br> <br>

<br> Anteil der Privathaushalte <br> mit mindestens einem Kind bis 17 Jahre <br> (mit mindestens einer Hauptwohnsitzperson) <br> an allen Privathaushalten in Prozent

## Haushalte mit Kindern

```{r}
#| context: server


addLegend_decreasing <- function (map, position = c("topright", "bottomright", "bottomleft","topleft"),
                                  pal, values, na.label = "NA", bins = 7, colors, 
                                  opacity = 0.5, labels = NULL, labFormat = labelFormat(), 
                                  title = NULL, className = "info legend", layerId = NULL, 
                                  group = NULL, data = getMapData(map), decreasing = FALSE) {
  
        position <- match.arg(position)
        type <- "unknown"
        na.color <- NULL
        extra <- NULL
        if (!missing(pal)) {
            if (!missing(colors)) 
                stop("You must provide either 'pal' or 'colors' (not both)")
            if (missing(title) && inherits(values, "formula")) 
                title <- deparse(values[[2]])
            values <- evalFormula(values, data)
            type <- attr(pal, "colorType", exact = TRUE)
            args <- attr(pal, "colorArgs", exact = TRUE)
            na.color <- args$na.color
            if (!is.null(na.color) && col2rgb(na.color, alpha = TRUE)[[4]] == 
                    0) {
                na.color <- NULL
            }
            if (type != "numeric" && !missing(bins)) 
                warning("'bins' is ignored because the palette type is not numeric")
            if (type == "numeric") {
                cuts <- if (length(bins) == 1) 
                    pretty(values, bins)
                else bins   
                if (length(bins) > 2) 
                    if (!all(abs(diff(bins, differences = 2)) <= 
                                     sqrt(.Machine$double.eps))) 
                        stop("The vector of breaks 'bins' must be equally spaced")
                n <- length(cuts)
                r <- range(values, na.rm = TRUE)
                cuts <- cuts[cuts >= r[1] & cuts <= r[2]]
                n <- length(cuts)
                p <- (cuts - r[1])/(r[2] - r[1])
                extra <- list(p_1 = p[1], p_n = p[n])
                p <- c("", paste0(100 * p, "%"), "")
                if (decreasing == TRUE){
                    colors <- pal(rev(c(r[1], cuts, r[2])))
                    labels <- rev(labFormat(type = "numeric", cuts))
                }else{
                    colors <- pal(c(r[1], cuts, r[2]))
                    labels <- rev(labFormat(type = "numeric", cuts))
                }
                colors <- paste(colors, p, sep = " ", collapse = ", ")
            }
            else if (type == "bin") {
                cuts <- args$bins
                n <- length(cuts)
                mids <- (cuts[-1] + cuts[-n])/2
                if (decreasing == TRUE){
                    colors <- pal(rev(mids))
                    labels <- rev(labFormat(type = "bin", cuts))
                }else{
                    colors <- pal(mids)
                    labels <- labFormat(type = "bin", cuts)
                }
            }
            else if (type == "quantile") {
                p <- args$probs
                n <- length(p)
                cuts <- quantile(values, probs = p, na.rm = TRUE)
                mids <- quantile(values, probs = (p[-1] + p[-n])/2, na.rm = TRUE)
                if (decreasing == TRUE){
                    colors <- pal(rev(mids))
                    labels <- rev(labFormat(type = "quantile", cuts, p))
                }else{
                    colors <- pal(mids)
                    labels <- labFormat(type = "quantile", cuts, p)
                }
            }
            else if (type == "factor") {
                v <- sort(unique(na.omit(values)))
                colors <- pal(v)
                labels <- labFormat(type = "factor", v)
                if (decreasing == TRUE){
                    colors <- pal(rev(v))
                    labels <- rev(labFormat(type = "factor", v))
                }else{
                    colors <- pal(v)
                    labels <- labFormat(type = "factor", v)
                }
            }
            else stop("Palette function not supported")
            if (!any(is.na(values))) 
                na.color <- NULL
        }
        else {
            if (length(colors) != length(labels)) 
                stop("'colors' and 'labels' must be of the same length")
        }
        legend <- list(colors = I(unname(colors)), labels = I(unname(labels)), 
                                     na_color = na.color, na_label = na.label, opacity = opacity, 
                                     position = position, type = type, title = title, extra = extra, 
                                     layerId = layerId, className = className, group = group)
        invokeMethod(map, data, "addLegend", legend)
        }

# ---- Play / Pause state）----
playing_3 <- reactiveVal(FALSE)

# Toggle play state when the button is clicked + update the button label accordingly
observeEvent(input$play_pause_3, {
  if (playing_3()) {
    playing_3(FALSE)
    updateActionButton(session, "play_pause_3", label = "▶ Play")
  } else {
    playing_3(TRUE)
    updateActionButton(session, "play_pause_3", label = "⏸ Pause")
  }
})

# Auto-advance the year (only runs while playing() == TRUE)
observe({
  req(playing_3())
  invalidateLater(1000, session)

  current   <- isolate(input$time_slider_3)
  next_year <- if (current >= MAX_YEAR) MIN_YEAR else current + 1L

  updateSliderInput(session, "time_slider_3", value = next_year)
})

# 1. Reaktive gefilterte Daten (immer aktuelles Jahr + gewählte Variable)
filtered_sf_data_3 <- reactive({
  final_sf_data_long %>% 
    filter(Jahr == input$time_slider_3) %>%
    select(
      sb_nummer,
      !!sym(MAP_NAME_COLUMN),
      geometry,
      Value = !!sym(input$variable_select_3)
    )
})

# 2. Grundkarte (wird einmal initialisiert)
output$map_output_3 <- renderLeaflet({
  leaflet(options = leafletOptions(minZoom = 10, maxZoom = 14)) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%  
    setView(lng = 11.5761, lat = 48.1372, zoom = 10)
})

# 3. Karte bei Änderung von Slider / Variable neu einfärben
observe({
  current_sf <- filtered_sf_data_3()
  var_id     <- input$variable_select_3
  var_label  <- names(variable_choices)[variable_choices == var_id]
  
  # ---- Farbbereich & Einheit je nach Variable ----
  if (var_id == "age_mean") {
    c_min <- GLOBAL_MIN_AGE;       c_max <- GLOBAL_MAX_AGE
    unit  <- " Jahre";             dec   <- 2
    pal_name <- "RdPu"
    
  } else if (var_id == "anteil") {
    c_min <- GLOBAL_MIN_ANTEIL;    c_max <- GLOBAL_MAX_ANTEIL
    unit  <- " %";                 dec   <- 1
    pal_name <- "Blues"
    
  } else if (var_id == "anteil_kinder") {
    c_min <- GLOBAL_MIN_KINDER;    c_max <- GLOBAL_MAX_KINDER
    unit  <- " %";                 dec   <- 1
    pal_name <- "Greens"
    
  } else if (var_id == "anteil_betreuung") {
    c_min <- GLOBAL_MIN_BETREUUNG; c_max <- GLOBAL_MAX_BETREUUNG
    unit  <- " %";                 dec   <- 1
    pal_name <- "Reds"
    
  } else {
    c_min <- GLOBAL_MIN_BABY;      c_max <- GLOBAL_MAX_BABY
    unit  <- "";                   dec   <- 4
    pal_name <- ""
  }
  
  pal <- colorNumeric(palette = pal_name, domain = c(c_min, c_max))
  
  popup_content <- paste0(
    "<b>Stadtteil:</b> ", current_sf[[MAP_NAME_COLUMN]], "<br/>",
    "<b>", var_label, ":</b> ", round(current_sf$Value, dec), unit
  )
  
  leafletProxy("map_output_3", data = current_sf) %>%
    clearShapes() %>%
    clearControls() %>%
    addPolygons(
      fillColor = ~pal(Value),
      weight = 1.5,
      opacity = 1,
      color = "white",
      dashArray = "1",
      fillOpacity = 0.7,
      label = lapply(popup_content, HTML),
      highlightOptions = highlightOptions(
        weight = 3,
        color  = "#666",
        fillOpacity = 0.9,
        bringToFront = TRUE
      )
    ) %>%
    addLegend_decreasing(
      pal      = pal,
      values   = c(c_min, c_max),
      opacity  = 0.7,
      title    = var_label,
      labFormat= labelFormat(suffix = unit, digits = dec),
      position = "bottomright",
      decreasing = TRUE
    ) %>%
   
    addControl(
      html = sprintf(
        "<div style='font-size:26px;
                     font-weight:bold;
                     background:rgba(255,255,255,0.8);
                     padding:4px 8px;
                     border-radius:4px;
                     box-shadow:0 0 3px rgba(0,0,0,0.3);'>
           Jahr: %s
         </div>",
        input$time_slider_3
      ),
      position = "topright"
    )
})
```

```{r}
#| panel: sidebar

selectInput(
  "variable_select_3",
  "",
  choices  = variable_choices,
  selected = "anteil_kinder"    
)

sliderInput(
  "time_slider_3",
  "Jahr",
  min     = 2012,
  max     = 2024,
  value   = 2012,
  step    = 1,
  sep     = "",
  animate = FALSE
)

actionButton(
  "play_pause_3",
  "▶ Play",
  width = "100%"
)
```

```{r}
#| panel: fill

leafletOutput("map_output_3", height = "550px")
```

## Korrelation (gesamt)

```{r}
#| label: hmk_korr_gesamt_point_sw
#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

hmk_korr_gesamt_point_sw
```

## Simpson's Paradox

```{r}
#| label: hmk_korr_point_line_nach_stadtteile_color
#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

hmk_korr_point_line_nach_stadtteile_color
```

## Korrelation (gesamt)

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

hmk_korr_gesamt_point_sw
```

## Korrelation (Jahre)

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 14
#| fig-height: 9
#| out.width: 100%
#| out.height: 100%
#| fig-dpi: 300

hmk_korr_point_line_nach_jahr_color

```

## Agenda {.agenda-slide}

1.  [Datenüberblick]{.dim-past}
2.  Datenanalyse
    -   [Frauenbeschäftigung]{.dim-past}
    -   Zusammenhang
        -   [Haushalte mit Kindern]{.dim-past}
        -   Kinderbetreuung
3.  [Fazit - Limitation - Ausblick]{.dim-future}

## Kinderbetreuung

<br><br><br>

::: {style="font-size:1.8rem;"}
$$
\text{Kinderbetreuung}
=
\dfrac{
  \hspace{0.6cm}\text{# Betreute Kinder (0–2 Jahre)}\hspace{0.6cm}
}{
  \hspace{0.6cm}\text{# Alle Kinder (0–2 Jahre)}\hspace{0.6cm}
}
\quad\times 100\%
$$
:::

------------------------------------------------------------------------

## Kinderbetreuung und Frauenbeschäftigung (2007–2024)

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 9
#| fig-height: 5
#| fig-dpi: 300
##| out.extra: 'style="margin-left:-60px;"'


ki_dual_trend
```

## Korrelation (gesamt)

<br>

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 7
#| fig-height: 4
#| fig-dpi: 300



ki_point_korr_gesamt_sw
```

## Korrelation (Stadtteile)

<br>

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 7
#| fig-height: 4
#| fig-dpi: 300



ki_korr_stadtteile_point_line_sw
```

## Korrelation (Jahre)

<br>

```{r}
#| echo: false
#| fig-align: center
#| fig-width: 11
#| fig-height: 5.5
#| fig-dpi: 300



ki_korr_jahre_point_line_rot
```

## Zusammenhang 2015

<br>

```{r}
#| echo: false
#| layout-ncol: 2
#| out.width: "100%"
#| fig-height: 8
#| fig-dpi: 300
#| fig-align: center

sv_map_2015
ki_map_2015
```

## Agenda {.agenda-slide}

1.  [Datenüberblick]{.dim-past}
2.  Datenanalyse
    -   [Frauenbeschäftigung]{.dim-past}
    -   Zusammenhang
        -   [Haushalte mit Kindern]{.dim-past}
        -   [Kinderbetreuung]{.dim-past}
3.  [Fazit - Limitation - Ausblick]{.dim-future}

## Korrelation (Jahre)

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

hmk_korr_point_line_nach_jahr_color

```

## Betreuungsbedingte Korrelation

<br>

-   **Gruppenaufteilung:**

    -   **Hohe Betreuung:** oberes Drittel der Stadtteile mit der höchsten Kinderbetreuung

    -   **Mittlere Betreuung:** mittleres Drittel der Stadtteile mit durchschnittlicher Kinderbetreuung

    -   **Niedrige Betreuung:** unteres Drittel der Stadtteile mit der niedrigsten Kinderbetreuung

## Betreuungsbedingte Korrelation

<br>

```{r}
#| context: server



# ---- Play / Pause ----
playing_scatter <- reactiveVal(FALSE)

observeEvent(input$play_pause_scatter, {
  if (playing_scatter()) {
    playing_scatter(FALSE)
    updateActionButton(session, "play_pause_scatter", label = "▶ Play")
  } else {
    playing_scatter(TRUE)
    updateActionButton(session, "play_pause_scatter", label = "⏸ Pause")
  }
})

###################
# ---- Compute fixed standardized axis limits (one-time global calculation)）----
axis_limits <- df_merged %>%
  filter(Raumbezug != "Stadt München") %>%
  group_by(Jahr) %>%
  mutate(
    x_std = as.numeric(scale(households_pct)),
    y_std = as.numeric(scale(emp_female_pct))
  ) %>%
  ungroup() %>%
  summarise(
    xmin = min(x_std, na.rm = TRUE),
    xmax = max(x_std, na.rm = TRUE),
    ymin = min(y_std, na.rm = TRUE),
    ymax = max(y_std, na.rm = TRUE)
  )

x_lim <- c(axis_limits$xmin, axis_limits$xmax)
y_lim <- c(axis_limits$ymin, axis_limits$ymax)

# ---- Year sequence ----
year_seq <- sort(unique(df_merged$Jahr))
year_min <- min(year_seq, na.rm = TRUE)
year_max <- max(year_seq, na.rm = TRUE)

observe({
  req(playing_scatter())
  invalidateLater(1000, session)
  current <- isolate(input$year)
  req(!is.null(current))

  idx <- match(current, year_seq)

  next_year <- if (is.na(idx) || idx >= length(year_seq)) {
    year_seq[1]
  } else {
    year_seq[idx + 1L]
  }

  updateSliderInput(session, "year", value = next_year)
})


# ---- Jahresdatensatz ----
df_year <- reactive({
  req(input$year)

  df_merged %>%
    filter(
      Jahr == input$year,
      Raumbezug != "Stadt München"
    ) %>%
    inner_join(
      df_betreut %>%
        filter(Jahr == input$year) %>%
        select(Raumbezug, anteil_betreut),
      by = "Raumbezug"
    )
})

# ---- Gruppierung: Hoch / Mittel / Niedrig ----
df_year_grouped <- reactive({
  d <- df_year()

  qs <- quantile(
    d$anteil_betreut,
    probs = c(0, 1/3, 2/3, 1),
    na.rm = TRUE
  )

  d %>%
    mutate(
      betreuung_group = cut(
        anteil_betreut,
        breaks = qs,
        labels = c("Niedrig", "Mittel", "Hoch"),
        include.lowest = TRUE
      )
    )
})

# ---- ⭐ Standardization (z-score) to ensure slopes reflect correlation strength ----
df_year_scaled <- reactive({
  df_year_grouped() %>%
    group_by(betreuung_group) %>%
    mutate(
      x_std = as.numeric(scale(households_pct)),
      y_std = as.numeric(scale(emp_female_pct))
    ) %>%
    ungroup()
})


# Farben
farben <- c(
  "Hohe Betreuung"     = "#8C3F00",
  "Mittel Betreuung"   = "#D97400",
  "Niedrige Betreuung" = "#FFB84D"
)

# Plot
output$plot <- renderPlot({

  df <- df_year_scaled()

  df <- df %>%
    mutate(gruppe = case_when(
      betreuung_group == "Hoch"    ~ "Hohe Betreuung",
      betreuung_group == "Mittel"  ~ "Mittel Betreuung",
      betreuung_group == "Niedrig" ~ "Niedrige Betreuung"
    ))

  ggplot(df) +

    # Punkte
    geom_point(
      aes(x = x_std, y = y_std, color = gruppe),
      size = 6, alpha = 0.9
    ) +

    # Regressionslinien
    geom_smooth(
      aes(x = x_std, y = y_std, color = gruppe),
      method = "lm",
      se = FALSE,
      linewidth = 5
    ) +

    scale_color_manual(values = farben, name = "Linien:") +

    labs(
      x = "Haushalte mit Kindern (standardisiert)",
      y = "Frauenbeschäftigung (standardisiert)"
    ) +

    annotate(
      "text",
      x = Inf, y = Inf,
      label = paste("Jahr:", input$year),
      hjust = 1.1, 
      vjust = 1.5,
      size = 20
    ) + 
    coord_cartesian(
  xlim = x_lim,
  ylim = y_lim
) +

   theme_bw(base_size = 28) +
    theme(
      plot.title      = element_text(size = 36, face = "bold"),
      axis.title      = element_text(size = 50, face = "bold"),
      axis.text       = element_text(size = 46),
      legend.title    = element_text(size = 50),
      legend.text     = element_text(size = 46)
    )

}, width = 1920, height = 1080)  
```

```{r}
#| panel: sidebar

sliderInput(
  "year",
  "Jahr:",
  min     = min(df_merged$Jahr),
  max     = max(df_merged$Jahr),
  value   = max(df_merged$Jahr),
  step    = 1,
  sep     = "",
  animate = FALSE
)

actionButton(
  "play_pause_scatter",
  "▶ Play",
  width = "100%"
)

```

```{r}
#| panel: fill
#| fill: true

plotOutput("plot") 
```

## Betreuungsbedarf 2024

<br>

```{r}

#| echo: false
#| out-width: 100%
#| out-height: 600px
#| fig-align: center

m_effekt_2.5

```

## Betreuungsbedarf 2024

<br>

```{r}
#| echo: false
#| layout-ncol: 2
#| out.width: "100%"
#| fig-height: 8
#| fig-dpi: 300
#| fig-align: center

m_effekt_04_plot
m_effekt_03_plot
```

## Agenda {.agenda-slide}

1.  [Datenüberblick]{.dim-past}
2.  [Datenanalyse]{.dim-future}
    -   [Frauenbeschäftigung]{.dim-past}
    -   [Zusammenhang]{.dim-future}
        -   [Haushalte mit Kindern]{.dim-past}
        -   [Kinderbetreuung]{.dim-past}
3.  Fazit - Limitation - Ausblick

## Fazit

::: {style="font-size:80%;"}
-   **Frauenbeschäftigung:**
    -   Zuwachs in allen Stadtteilen
    -   Zentrale Stadtteile höhere Anteil, periphere Stadtteile niedrigere Anteil
-   [**Haushalte mit Kindern:**]{style="color:lightgray;"}
    -   [Nach Stadtteil: meistens positive Korrelation]{style="color:lightgray;"}
    -   [Nach Jahr: negative Korrelation, die sich über die Zeit verstärkt]{style="color:lightgray;"}
-   [**Kinderbetreuung:**]{style="color:lightgray;"}
    -   [Nach Stadtteil: stark positive Korrelation]{style="color:lightgray;"}
    -   [Nach Jahr: negative Korrelation]{style="color:lightgray;"}
    -   [Höhere Kinderbetreuung schwächt die negative Korrelation zwischen Frauenbeschäftigung und Haushalten mit Kindern]{style="color:lightgray;"}
:::

## Fazit

::: {style="font-size:80%;"}
-   [**Frauenbeschäftigung:**]{style="color:lightgray;"}
    -   [Zuwachs in allen Stadtteilen]{style="color:lightgray;"}
    -   [Zentrale Stadtteile höhere Anteil, periphere Stadtteile niedrigere Anteil]{style="color:lightgray;"}
-   **Haushalte mit Kindern:**
    -   Nach Stadtteil: meistens positive Korrelation
    -   Nach Jahr: negative Korrelation, die sich über die Zeit verstärkt
-   **Kinderbetreuung:**
    -   Nach Stadtteil: stark positive Korrelation
    -   Nach Jahr: negative Korrelation
    -   Höhere Kinderbetreuung schwächt die negative Korrelation zwischen Frauenbeschäftigung und Haushalten mit Kindern
:::

## Limitation

::: {style="font-size:85%;"}
-   **Sozialversicherungspflichtige Beschäftigung:**\
    -   Nicht alle Erwerbstätigen umfassen
-   [**Altersgruppen nicht vollständig kompatibel:**]{style="color:lightgray;"}\
    -   [Nur 0–2 Jahre stimmen überein]{style="color:lightgray;"}
    -   [Andere Altersgruppen sind nicht vergleichbar]{style="color:lightgray;"}
-   [**Unterschiedliche Zeitabdeckung:**]{style="color:lightgray;"}
    -   [Daten über Frauenbeschäftigung ab 2000]{style="color:lightgray;"}
    -   [Daten über Kinderbetreuung ab 2007]{style="color:lightgray;"}
    -   [Daten über Haushalte mit Kindern ab 2012]{style="color:lightgray;"}
:::

## Limitation

::: {style="font-size:85%;"}
-   [**Sozialversicherungspflichtige Beschäftigung:**]{style="color:lightgray;"}\
    -   [Nicht alle Erwerbstätigen umfassen]{style="color:lightgray;"}
-   **Altersgruppen nicht vollständig kompatibel:**\
    -   Nur 0–2 Jahre stimmen überein
    -   Andere Altersgruppen sind nicht vergleichbar
-   [**Unterschiedliche Zeitabdeckung:**]{style="color:lightgray;"}
    -   [Daten über Frauenbeschäftigung ab 2000]{style="color:lightgray;"}
    -   [Daten über Kinderbetreuung ab 2007]{style="color:lightgray;"}
    -   [Daten über Haushalte mit Kindern ab 2012]{style="color:lightgray;"}
:::

## Limitation

::: {style="font-size:85%;"}
-   [**Sozialversicherungspflichtige Beschäftigung:**]{style="color:lightgray;"}\
    -   [Nicht alle Erwerbstätigen umfassen]{style="color:lightgray;"}
-   [**Altersgruppen nicht vollständig kompatibel:**]{style="color:lightgray;"}\
    -   [Nur 0–2 Jahre stimmen überein]{style="color:lightgray;"}
    -   [Andere Altersgruppen sind nicht vergleichbar]{style="color:lightgray;"}
-   **Unterschiedliche Zeitabdeckung:**
    -   Daten über Frauenbeschäftigung ab 2000
    -   Daten über Kinderbetreuung ab 2007
    -   Daten über Haushalte mit Kindern ab 2012
:::

## Ausblick

::: {style="font-size:85%;"}
-   **Feinere Datenebene:**
    -   Stadtteile durch Postleitzahlen ersetzen
-   [**Kinderbetreuung und Frauenbeschäftigung weiter untersuchen:**]{style="color:lightgray;"}
    -   [Politische und zeitliche Effekte berücksichtigen (Kita-Ausbau, Mini-Job)]{style="color:lightgray;"}
-   [**moderieren:**]{style="color:lightgray;"}
    -   [Moderierte Effekte mit komplexeren Modellen lernen und anwenden]{style="color:lightgray;"}
:::

## Ausblick

::: {style="font-size:85%;"}
-   [**Feinere Datenebene:**]{style="color:lightgray;"}
    -   [Stadtteile durch Postleitzahlen ersetzen]{style="color:lightgray;"}
-   **Kinderbetreuung und Frauenbeschäftigung weiter untersuchen:**
    -   Politische und zeitliche Effekte berücksichtigen (Kita-Ausbau, Mini-Job)
-   [**moderieren:**]{style="color:lightgray;"}
    -   [Moderierte Effekte mit komplexeren Modellen lernen und anwenden]{style="color:lightgray;"}
:::

## Ausblick

::: {style="font-size:85%;"}
-   [**Feinere Datenebene:**]{style="color:lightgray;"}
    -   [Stadtteile durch Postleitzahlen ersetzen]{style="color:lightgray;"}
-   [**Kinderbetreuung und Frauenbeschäftigung weiter untersuchen:**]{style="color:lightgray;"}
    -   [Politische und zeitliche Effekte berücksichtigen (Kita-Ausbau, Mini-Job)]{style="color:lightgray;"}
-   **moderieren:**
    -   Moderierte Effekte mit komplexeren Modellen lernen und anwenden
:::

## 

![](images/clipboard-3386569485.png)

## Anhang

![](images/clipboard-1906228731.png)

## Betreuungsbedingte Korrelation

```{r}
#| context: server

#─────── 5. Shiny：Betreuungsbedingte Korrelation ────────────

#─── Compute fixed standardized axis limits (one-time global calculation)） ────────

axis_limits5 <- df_merged %>%
  filter(Raumbezug != "Stadt München") %>%
  summarise(
    x_min = min(households_pct, na.rm = TRUE),
    x_max = max(households_pct, na.rm = TRUE),
    y_min = min(emp_female_pct, na.rm = TRUE),
    y_max = max(emp_female_pct, na.rm = TRUE)
  )

x_lim5 <- c(axis_limits5$x_min, axis_limits5$x_max)
y_lim5 <- c(axis_limits5$y_min, axis_limits5$y_max)




# ---- Play / Pause ----
playing_scatter5 <- reactiveVal(FALSE)

observeEvent(input$play_pause_scatter5, {
  if (playing_scatter5()) {
    playing_scatter5(FALSE)
    updateActionButton(session, "play_pause_scatter5", label = "▶ Play")
  } else {
    playing_scatter5(TRUE)
    updateActionButton(session, "play_pause_scatter5", label = "⏸ Pause")
  }
})

# ---- Year sequence ----
year_seq5 <- sort(unique(df_merged$Jahr))
year_min5 <- min(year_seq5, na.rm = TRUE)
year_max5 <- max(year_seq5, na.rm = TRUE)

# ---- Auto-Play (5) ----
AUTO_MS5 <- 1000  

observe({
  req(playing_scatter5())
  invalidateLater(AUTO_MS5, session)
  current <- isolate(input$year5)
  req(!is.null(current))
  idx <- match(current, year_seq5)

  next_year <- if (is.na(idx) || idx >= length(year_seq5)) {
    year_seq5[1]
  } else {
    year_seq5[idx + 1L]
  }

  updateSliderInput(session, "year5", value = next_year)
})


# ---- Jahresdatensatz ----
df_year5 <- reactive({
  req(input$year5)

  df_merged %>%
    filter(
      Jahr == input$year5,
      Raumbezug != "Stadt München"
    ) %>%
    inner_join(
      df_betreut %>%
        filter(Jahr == input$year5) %>%
        select(Raumbezug, anteil_betreut),  
      by = "Raumbezug"
    )
})

# ---- Gruppierung: Hoch / Mittel / Niedrig ----
df_year_grouped5 <- reactive({
  d <- df_year5()

  qs <- quantile(
    d$anteil_betreut,
    probs = c(0, 1/3, 2/3, 1),
    na.rm = TRUE
  )

  d %>%
    mutate(
      betreuung_group = cut(           
        anteil_betreut,
        breaks = qs,
        labels = c("Niedrig", "Mittel", "Hoch"),
        include.lowest = TRUE
      )
    )
})

# ---- De-standardized version (no scaling applied) ----

df_year_scaled5 <- reactive({
  df_year_grouped5()   
})

# Farben
farben5 <- c(
  "Hohe Betreuung"     = "#8C3F00",
  "Mittel Betreuung"   = "#D97400",
  "Niedrige Betreuung" = "#FFB84D"
)

output$plot5 <- renderPlot({

  df <- df_year_scaled5()

df <- df %>%
  mutate(gruppe = case_when(
    betreuung_group == "Hoch"    ~ "Hohe Betreuung",
    betreuung_group == "Mittel"  ~ "Mittel Betreuung",
    betreuung_group == "Niedrig" ~ "Niedrige Betreuung"
  )) %>%
  filter(!is.na(gruppe))  

  ggplot(df) +

    geom_point(
      aes(x = households_pct, y = emp_female_pct, color = gruppe),
      size = 6, alpha = 0.9
    ) +

    geom_smooth(
      aes(x = households_pct, y = emp_female_pct, color = gruppe),
      method = "lm",
      se = FALSE,
      linewidth = 5
    ) +

    scale_color_manual(values = farben5, name = "Linien:") +

    labs(
      x = "Haushalte mit Kindern (%)",
      y = "Frauenbeschäftigung (%)"
    ) +

    annotate(
      "text",
      x = Inf, y = Inf,
      label = paste("Jahr:", input$year5),
      hjust = 1.1,
      vjust = 1.5,
      size = 20
    ) +
    coord_cartesian(
  xlim = x_lim5,
  ylim = y_lim5
) +

    theme_bw(base_size = 28) +
    theme(
      plot.title      = element_text(size = 36, face = "bold"),
      axis.title      = element_text(size = 50, face = "bold"),
      axis.text       = element_text(size = 46),
      legend.title    = element_text(size = 50),
      legend.text     = element_text(size = 46)
    )

}, width = 1920, height = 1080)
```

```{r}
#| panel: sidebar

sliderInput(
  "year5",
  "Jahr:",
  min     = min(df_merged$Jahr),
  max     = max(df_merged$Jahr),
  value   = max(df_merged$Jahr),
  step    = 1,
  sep     = "",
  animate = FALSE
)

actionButton(
  "play_pause_scatter5",
  "▶ Play",
  width = "100%"
)
```

```{r}
#| panel: fill
#| fill: true

plotOutput("plot5")
```

## Betreuungsbedarf

```{r}
#| context: server

#──────────────────────── 4. Shiny：HK hoch + Beschäftigung niedrig vs. Kinderbetreuung ────────────────────────


if (!exists("full_data_4", inherits = TRUE)) {
  
  # Haushalte mit Kindern
  hh_long_4 <- be_sheet %>%
    dplyr::filter(
      Indikator == "Haushalte mit Kindern",
      Ausprägung == "insgesamt",
      Raumbezug != "Stadt München"
    ) %>%
    dplyr::mutate(
      bezirksnummer = sprintf("%02d", as.numeric(stringr::str_extract(Raumbezug, "^\\d+"))),
      anteil_kinder = 100 * `Basiswert 1` / `Basiswert 2`
    ) %>%
    dplyr::select(Jahr, bezirksnummer, anteil_kinder)
  
  # Frauenbeschäftigung
  emp_long_4 <- ar_sheet %>%
    dplyr::filter(
      Indikator == "Sozialversicherungspflichtig Beschäftigte - Anteil",
      Ausprägung == "weiblich",
      Raumbezug != "Stadt München"
    ) %>%
    dplyr::mutate(
      bezirksnummer = sprintf("%02d", as.numeric(stringr::str_extract(Raumbezug, "^\\d+"))),
      anteil = 100 * `Basiswert 1` / `Basiswert 2`
    ) %>%
    dplyr::select(Jahr, bezirksnummer, anteil)
  
  # Kinderbetreuung bis 2 Jahre：gesamt Anzahl
  total_long_4 <- be_sheet %>%
    dplyr::filter(
      Indikator == "Altersgruppen",
      Ausprägung == "bis 2 Jahre",
      Raumbezug != "Stadt München"
    ) %>%
    dplyr::mutate(
      bezirksnummer = sprintf("%02d", as.numeric(stringr::str_extract(Raumbezug, "^\\d+")))
    ) %>%
    dplyr::select(Jahr, bezirksnummer, kinder_total = `Basiswert 1`)
  
  # Kinderbetreuung bis 2 Jahre：Anzahl von betreut Kinder
  betreut_long_4 <- ki_sheet %>%
    dplyr::filter(
      Indikator == "Altersgruppen",
      Ausprägung == "bis 2 Jahre",
      Raumbezug != "Stadt München"
    ) %>%
    dplyr::mutate(
      bezirksnummer = sprintf("%02d", as.numeric(stringr::str_extract(Raumbezug, "^\\d+")))
    ) %>%
    dplyr::select(Jahr, bezirksnummer, kinder_betreut = `Basiswert 1`)
  
  # Anteil der betreut Kinder
  betreuung_long_4 <- total_long_4 %>%
    dplyr::left_join(betreuet_long_4 <- betreut_long_4,
                     by = c("Jahr", "bezirksnummer")) %>%
    dplyr::mutate(
      anteil_betreuung = 100 * kinder_betreut / kinder_total
    ) %>%
    dplyr::select(Jahr, bezirksnummer, anteil_betreuung)
  
  # geometry
  full_data_4 <<- hh_long_4 %>%
    dplyr::left_join(emp_long_4,       by = c("Jahr", "bezirksnummer")) %>%
    dplyr::left_join(betreuung_long_4, by = c("Jahr", "bezirksnummer")) %>%
    dplyr::left_join(munich_map,       by = c("bezirksnummer" = "sb_nummer")) %>%
    sf::st_as_sf()
}

# ---- Play/ Pause ----
playing_4 <- reactiveVal(FALSE)

observeEvent(input$play_4, {
  if (playing_4()) {
    playing_4(FALSE)
    updateActionButton(session, "play_4", label = "▶ Play")
  } else {
    playing_4(TRUE)
    updateActionButton(session, "play_4", label = "⏸ Pause")
  }
})


observe({
  req(playing_4())
  invalidateLater(1000, session)  
  
  current_year <- isolate(input$year_4)
  next_year    <- if (current_year >= 2024) 2012 else current_year + 1L
  
  updateSliderInput(session, "year_4", value = next_year)
})

# ---- Compute yearly Munich means (Households with Children & Female Employment) 

city_means_4 <- reactive({
  tibble::tibble(
    mean_HaKi_4 = be_sheet %>%
      dplyr::filter(
        Jahr == input$year_4,
        Raumbezug == "Stadt München",
        Indikator == "Haushalte mit Kindern",
        Ausprägung == "insgesamt"
      ) %>%
      dplyr::mutate(val = 100 * `Basiswert 1` / `Basiswert 2`) %>%
      dplyr::pull(val),
    
    mean_FE_4 = ar_sheet %>%
      dplyr::filter(
        Jahr == input$year_4,
        Raumbezug == "Stadt München",
        Indikator == "Sozialversicherungspflichtig Beschäftigte - Anteil",
        Ausprägung == "weiblich"
      ) %>%
      dplyr::mutate(val = 100 * `Basiswert 1` / `Basiswert 2`) %>%
      dplyr::pull(val)
  )
})


df_year_4 <- reactive({
  full_data_4 %>%
    dplyr::filter(Jahr == input$year_4)
})

# -------------------------------------------------
# -------------------------------------------------
output$map_left_4 <- leaflet::renderLeaflet({
  
  d <- df_year_4()
  m <- city_means_4()
  
  d <- d %>%
    dplyr::mutate(
      gruppe_4 = dplyr::case_when(
        anteil_kinder > m$mean_HaKi_4 & anteil < m$mean_FE_4 ~
          "HK hoch + Beschäftigung niedrig",
        TRUE ~ "Andere"
      ),
      color_4 = dplyr::if_else(
        gruppe_4 == "HK hoch + Beschäftigung niedrig",
        "#e75480", "#d9d9d9"
      )
    )
  

  popup_left_4 <- paste0(
    "<b>", d[[MAP_NAME_COLUMN]], "</b><br>",
    "Haushalte mit Kindern: ", round(d$anteil_kinder, 1), "%<br>",
    "Frauenbeschäftigung: ",  round(d$anteil, 1), "%<br>",
    "Kinderbetreuung 0–2: ",  round(d$anteil_betreuung, 1), "%"
  )
  
  leaflet::leaflet(d) %>%
    leaflet::addTiles(urlTemplate = "https://basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png") %>%
    leaflet::addPolygons(
      fillColor   = ~color_4,
      color       = "white",
      weight      = 1,
      fillOpacity = 0.8,
      label       = lapply(popup_left_4, htmltools::HTML)
    )
})

# -------------------------------------------------
# -------------------------------------------------
output$map_right_4 <- leaflet::renderLeaflet({
  
  d <- df_year_4()
  

  pal_4 <- leaflet::colorNumeric(
    palette = c("#fff5eb", "#7f2704"),
    domain  = c(0, 100)
  )
  
  popup_right_4 <- paste0(
    "<b>", d[[MAP_NAME_COLUMN]], "</b><br>",
    "Kinderbetreuung 0–2: ", round(d$anteil_betreuung, 1), "%"
  )
  
  leaflet::leaflet(d) %>%
    leaflet::addTiles(
      urlTemplate = "https://basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
    ) %>%
    leaflet::addPolygons(
      fillColor   = ~pal_4(anteil_betreuung),
      color       = "white",
      weight      = 1,
      fillOpacity = 0.8,
      label       = lapply(popup_right_4, htmltools::HTML)
    ) %>%
    leaflet::addLegend(
      pal      = pal_4,
      values   = c(0, 100),
      title    = "Betreuung 0–2 Jahre (%)",
      position = "bottomright",
      className = "small-legend"   
    ) %>%
    htmlwidgets::prependContent(  
      htmltools::tags$style(htmltools::HTML("
        .small-legend {
          font-size: 10px !important;
          line-height: 10px !important;
          padding: 3px !important;
        }
        .small-legend .leaflet-control-legend-scale {
          height: 6px !important;
        }
      "))
    )
})
```

```{r}
#| panel: sidebar

sliderInput(
  "year_4",
  "Jahr:",
  min   = 2012,
  max   = 2024,
  value = 2024,
  step  = 1,
  sep   = ""
)

actionButton(
  "play_4",
  "▶ Play",
  width = "100%"
)
```

```{r}
#| panel: fill

tagList(
  h4(""),
  leafletOutput("map_left_4", height = "250px"),
  br(),
  h4(""),
  leafletOutput("map_right_4", height = "250px")
)
```

## Betreuungsbedarf

<br><br>

::::: columns
::: column
```{r}
#| echo: false
#| out.width: "100%"
#| out.height: "400px"
#| 
#| 

m_effekt_04
```
:::

::: column
```{r}
#| echo: false
#| out.width: "100%"
#| out.height: "400px"




m_effekt_03
```
:::
:::::

## Anhang

Geburtenrate

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

geburtenrate_dual_trend

```

------------------------------------------------------------------------

Geburtenrate

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 21
#| fig-height: 13
#| fig-dpi: 300

geburtenrate_trend_nach_stadtteile

```

------------------------------------------------------------------------

Geburtenrate

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

geburtenrate_korr_nach_stadtteile

```

------------------------------------------------------------------------

Geburtenrate

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

geburtenrate_korr_trend_nach_jahr

```

------------------------------------------------------------------------

### Durchschnittsalter Mütter erstgebärend

![](images/clipboard-3427736359.png)

------------------------------------------------------------------------

### Durchschnittsalter Mütter erstgebärend

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

mea_gesamt_sw

```

------------------------------------------------------------------------

### Durchschnittsalter Mütter erstgebärend

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

mea_korr_nach_stadtteilen_point

```

------------------------------------------------------------------------

### Durchschnittsalter Mütter erstgebärend

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

mea_korr_nach_stadtteilen_point_line

```

------------------------------------------------------------------------

### Durchschnittsalter Mütter erstgebärend

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

mea_korr_jahr_point

```

------------------------------------------------------------------------

### Durchschnittsalter Mütter erstgebärend

```{r}

#| echo: false
#| fig-align: center
#| fig-width: 16
#| fig-height: 9
#| fig-dpi: 300

mea_korr_jahr_point_line

```

## Anhang

![](images/clipboard-2548173776.png)

## Anhang

![](images/clipboard-1826208890.png)

## Anhang

![](images/clipboard-2856450415.png)

## Anhang

![](images/clipboard-3397125107.png)
